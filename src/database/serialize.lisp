;; Core Server: Web Application Server

;; Copyright (C) 2006-2008  Metin Evrim Ulu, Aycan iRiCAN

;; This program is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <http://www.gnu.org/licenses/>.

(in-package :core-server)

(defclass+ serialization-cache ()
  ((counter :initform 0)
   (cache :initform (make-hash-table)))
  (:ctor ()))

(defmacro with-cached-object ((id object stream cache) &body body)
  `(multiple-value-bind (id foundp) (gethash ,object (serialization-cache.cache ,cache))
     (cond
       (foundp
	(string! ,stream "<REF ID=\"")
	(fixnum! ,stream id)
	(string! ,stream "\"/>"))
       (t
	(setf ,id (incf (serialization-cache.counter ,cache))
	      (gethash ,object (serialization-cache.cache ,cache)) ,id)
	,@body))))

(defmethod serialize-xml ((stream core-stream) (object t) (cache serialization-cache))
  (declare (ignore stream cache))
  (error "Cant serialize ~A" object))

(defmethod serialize-xml ((stream core-stream) (object null) (cache serialization-cache))
  (declare (ignore cache))
  (string! stream "<NULL/>"))

(defmethod serialize-xml ((stream core-stream) (object (eql 't)) (cache serialization-cache))
  (declare (ignore cache))
  (string! stream "<TRUE/>"))

(defmethod serialize-xml ((stream core-stream) (object symbol) (cache serialization-cache))
  (declare (ignore cache))
  (string! stream "<SYMBOL>")
  (symbol-with-package! stream object)
  (string! stream "</SYMBOL>"))

(defmethod serialize-xml ((stream core-stream) (object character) (cache serialization-cache))
  (declare (ignore cache))
  (string! stream "<CHARACTER>")
  (char! stream object)
  (string! stream "</CHARACTER>"))

(defmethod serialize-xml ((stream core-stream) (object integer) (cache serialization-cache))
  (declare (ignore cache))
  (string! stream "<INT>")
  (fixnum! stream object)
  (string! stream "</INT>"))

(defmethod serialize-xml ((stream core-stream) (object ratio) (cache serialization-cache))
  (declare (ignore cache))
  (string! stream "<RATIO>")
  (string! stream (format nil "~A" object))
  (string! stream "</RATIO>"))

(defmethod serialize-xml ((stream core-stream) (object complex) (cache serialization-cache))
  (declare (ignore cache))
  (string! stream "<COMPLEX>")
  (string! stream (format nil "~A" object))
  (string! stream "</COMPLEX>"))

(defmethod serialize-xml ((stream core-stream) (object float) (cache serialization-cache))
  (declare (ignore cache))
  (string! stream "<FLOAT>")
  (string! stream (format nil "~A" object))
  (string! stream "</FLOAT>"))

(defmethod serialize-xml ((stream core-stream) (object string) (cache serialization-cache))
  (with-cached-object (id object stream cache)
    (string! stream "<STRING ID=\"")
    (fixnum! stream id)
    (string! stream "\">")
    (quoted! stream object)
    (string! stream "</STRING>")))

(defmethod serialize-xml ((stream core-stream) (object vector) (cache serialization-cache))
  (with-cached-object (id object stream cache)
    (string! stream "<VECTOR ID=\"")
    (fixnum! stream id)
    (string! stream "\" SIZE=\"")
    (fixnum! stream (length object))
    (string! stream "\">")
    (reduce (rcurry #'serialize-xml cache) object :initial-value stream)
    (string! stream "</VECTOR>")))

(defmethod serialize-xml ((stream core-stream) (object list) (cache serialization-cache))
  (with-cached-object (id object stream cache)
    (if (atom (cdr object))
	(progn
	  (string! stream "<CONS ID=\"")
	  (fixnum! stream id)
	  (string! stream "\">")
	  (serialize-xml stream (car object) cache)
	  (serialize-xml stream (cdr object) cache)
	  (string! stream "</CONS>"))
	(progn
	  (string! stream "<LIST ID=\"")
	  (fixnum! stream id)
	  (string! stream "\" SIZE=\"")
	  (fixnum! stream (length object))
	  (string! stream "\">")
	  (reduce (rcurry #'serialize-xml cache) object :initial-value stream)
	  (string! stream "</LIST>")))))

(defmethod serialize-xml ((stream core-stream) (object hash-table) (cache serialization-cache))
  (with-cached-object (id object stream cache)
    (string! stream "<HASH-TABLE ID=\"")
    (fixnum! stream id)
    (string! stream "\" TEST=\"")
    (symbol-with-package! stream (hash-table-test object))
    (string! stream "\" SIZE=\"")
    (fixnum! stream (hash-table-size object))
    (string! stream "\">")
    (maphash (lambda (k v)
	       (string! stream "<ENTRY><KEY>")
	       (serialize-xml stream k cache)
	       (string! stream "</KEY><VALUE>")
	       (serialize-xml stream v cache)
	       (string! stream "</VALUE>"))
	     object)
    (string! stream "</HASH-TABLE>")))

(defmethod serialize-xml ((stream core-stream) (object structure-object)
			  (cache serialization-cache))
  (with-cached-object (id object stream cache)
      (string! stream "<STRUCT ID=\"")
      (fixnum! stream id)
      (string! stream "\" CLASS=\"")
    (symbol-with-package! stream (class-name (class-of object)))
    (string! stream "\">")
    (mapc (lambda (slot)
	    (string! stream "<SLOT NAME=\"")
	    (symbol-with-package! stream slot)
	    (string! stream "\">")
	    (serialize-xml stream (slot-value object slot) cache)
	    (string! stream "</SLOT>"))
	  (slots-of object))
    (string! stream "</STRUCT>")))

(defmethod serialize-xml ((stream core-stream) (object standard-object)
			  (cache serialization-cache))
  (with-cached-object (id object stream cache)
    (string! stream "<OBJECT ID=\"")
    (fixnum! stream id)
    (string! stream "\" CLASS=\"")
    (symbol-with-package! stream (class-name (class-of object)))
    (string! stream "\">")
    (mapc (lambda (slot)
	    (string! stream "<SLOT NAME=\"")
	    (symbol-with-package! stream slot)
	    (string! stream "\">")
	    (serialize-xml stream (slot-value object slot) cache)
	    (string! stream "</SLOT>"))
	  (slots-of object))
    (string! stream "</OBJECT>")))

(defmethod deserialize-xml ((stream core-stream) (cache serialization-cache))
  (macrolet ((with-cached-object ((element) result)
	       `(setf (gethash (parse-integer (get-attribute ,element "ID"))
			       (serialization-cache.cache cache))
		      ,result)))
    (labels ((deserialize (element)	       
	       (let ((tag (dom.tag element)))
		 (cond		   
		   ((string= "REF" tag)
		    (gethash (parse-integer (get-attribute element "ID"))
			     (serialization-cache.cache cache)))
		   ((string= "NULL" tag)
		    nil)
		   ((string= "TRUE" tag)
		    t)
		   ((string= "CHARACTER" tag)
		    (aref (car (dom.children element)) 0))
		   ((or (string= "SYMBOL" tag)
			(string= "INT" tag)
			(string= "RATIO" tag)
			(string= "COMPLEX" tag)
			(string= "FLOAT" tag))
		    (read-from-string (car (dom.children element))))
		   ((string= "STRING" tag)
		    (with-cached-object (element)		      
		      (quoted? (make-core-stream (car (dom.children element))))))
		   ((string= "VECTOR" tag)
		    (map-into nil #'deserialize (dom.children element)))
		   ((string= "CONS" tag)
		    (with-cached-object (element)
		      (cons (deserialize (car (dom.children element)))
			    (deserialize (cadr (dom.children element))))))
		   ((string= "LIST" tag)
		    (with-cached-object (element)		      
		      (mapcar #'deserialize (dom.children element))))
		   ((string= "HASH-TABLE" tag)
		    (with-cached-object (element)
		      (let* ((test (read-from-string (get-attribute element "TEST")))
			     (table (make-hash-table :test test)))
			(mapc (lambda (entry)
				(setf (gethash (deserialize
						(car (dom.children (car (dom.children entry)))))
					       table)
				      (deserialize (car (dom.children (cadr (dom.children entry)))))))
			      (dom.children element))
			table)))
		   ((string= "STRUCT" tag)
		    (with-cached-object (element)
		      (let* ((class (read-from-string (get-attribute element "CLASS")))
			     (object (funcall (intern (format nil "MAKE-~A" (symbol-name class))
						      (symbol-package class)))))
			(mapc (lambda (slot)
				(let ((slot-name (read-from-string (get-attribute slot "NAME"))))
				  (when (slot-exists-p object slot-name)
				    (setf (slot-value object slot-name)
					  (deserialize (car (dom.children slot)))))))
			      (dom.children element))
			object)))
		   ((string= "OBJECT" tag)
		    (with-cached-object (element)
		      (let* ((class (read-from-string (get-attribute element "CLASS")))
			     (object (make-instance class)))
			(mapc (lambda (slot)
				(let ((slot-name (read-from-string (get-attribute slot "NAME"))))
				  (when (slot-exists-p object slot-name)
				    (setf (slot-value object slot-name)
					  (deserialize (car (dom.children slot)))))))
			      (dom.children element))
			object)))
		   (t
		    (if (null element)
			(error "Bogus prevalence stream ~A" stream)
			(error "Cant deserialize ~A" element)))))))
      (aif (dom-element? stream)
	   (values (deserialize it) cache)
	   (values nil cache)))))
